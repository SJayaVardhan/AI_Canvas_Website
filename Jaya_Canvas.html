<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Canvas</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #050510 0%, #0a0a1f 50%, #0f0f2a 100%);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Animated Background */
        .animated-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 20% 80%, rgba(124, 58, 237, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(167, 139, 250, 0.2) 0%, transparent 50%);
            animation: float 8s ease-in-out infinite;
            z-index: -1;
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0px) rotate(0deg);
            }

            50% {
                transform: translateY(-20px) rotate(1deg);
            }
        }

        /* Header */
        .header {
            text-align: center;
            padding: 30px 20px;
            background: rgba(15, 15, 42, 0.3);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(124, 58, 237, 0.2);
        }

        .title {
            font-size: 3.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #ffffff 0%, #a78bfa 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            animation: glow 3s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                filter: drop-shadow(0 0 10px rgba(124, 58, 237, 0.5));
            }

            to {
                filter: drop-shadow(0 0 20px rgba(167, 139, 250, 0.8));
            }
        }

        .subtitle {
            font-size: 1.2rem;
            color: #9ca3af;
            opacity: 0;
            animation: fadeInUp 1s ease-out 0.5s forwards;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Main Container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Canvas Area */
        .canvas-wrapper {
            position: relative;
            margin: 20px 0;
            border-radius: 20px;
            background: rgba(15, 15, 42, 0.5);
            backdrop-filter: blur(15px);
            border: 3px solid;
            border-image: linear-gradient(135deg, #7c3aed, #a78bfa) 1;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5),
                0 0 40px rgba(124, 58, 237, 0.3);
            overflow: hidden;
        }

        .canvas-container {
            position: relative;
            height: 500px;
            background: #0f0f2a;
            border-radius: 16px;
            margin: 4px;
        }

        #drawingCanvas {
            width: 100%;
            height: 100%;
            border-radius: 16px;
            cursor: crosshair;
            display: block;
        }

        /* Welcome Message */
        .welcome-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #6b7280;
            pointer-events: none;
            z-index: 1;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .welcome-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            animation: float 3s ease-in-out infinite;
        }

        .welcome-text {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: #9ca3af;
        }

        .welcome-hint {
            font-size: 1rem;
            color: #6b7280;
        }

        /* Controls */
        .controls {
            background: rgba(10, 10, 31, 0.8);
            backdrop-filter: blur(15px);
            border-radius: 16px;
            padding: 20px 30px;
            margin: 20px 0;
            border: 1px solid rgba(124, 58, 237, 0.3);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3);
        }

        .controls-grid {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .control-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-right: 10px;
        }

        /* Pen Size Controls */
        .pen-sizes {
            display: flex;
            gap: 8px;
        }

        .pen-size {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            background: #1f2937;
            border: 2px solid transparent;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .pen-size::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .pen-size:hover::before {
            left: 100%;
        }

        .pen-size:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px -5px rgba(124, 58, 237, 0.5);
        }

        .pen-size.active {
            background: #7c3aed;
            border-color: #a78bfa;
            box-shadow: 0 0 20px rgba(124, 58, 237, 0.6);
        }

        /* Color Picker */
        .color-picker {
            display: flex;
            gap: 8px;
        }

        .color-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid #1f2937;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .color-btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s ease;
        }

        .color-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .color-btn:hover::after {
            width: 100%;
            height: 100%;
        }

        .color-btn.active {
            border-color: #7c3aed;
            box-shadow: 0 0 15px rgba(124, 58, 237, 0.8);
            transform: scale(1.1);
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: linear-gradient(135deg, #7c3aed, #a78bfa);
            color: white;
            box-shadow: 0 5px 15px rgba(124, 58, 237, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(124, 58, 237, 0.6);
        }

        .btn-primary:disabled {
            background: #4b5563;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #1f2937;
            color: white;
            border: 1px solid #374151;
        }

        .btn-secondary:hover {
            background: #374151;
            transform: translateY(-1px);
        }

        /* Processing Overlay */
        .processing-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 15, 42, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 5;
            flex-direction: column;
            gap: 20px;
        }

        .processing-steps {
            text-align: center;
            color: #9ca3af;
        }

        .processing-step {
            margin: 10px 0;
            opacity: 0.5;
            transition: all 0.3s ease;
        }

        .processing-step.active {
            opacity: 1;
            color: #7c3aed;
        }

        .processing-step.completed {
            opacity: 1;
            color: #10b981;
        }

        /* Result Display */
        .result-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 15, 42, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .result-content {
            max-width: 800px;
            padding: 40px;
            text-align: center;
            background: rgba(15, 15, 42, 0.9);
            border-radius: 20px;
            border: 2px solid #7c3aed;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            animation: resultSlideIn 0.5s ease-out;
        }

        @keyframes resultSlideIn {
            from {
                opacity: 0;
                transform: translateY(30px) scale(0.9);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .result-section {
            margin: 30px 0;
        }

        .result-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
        }

        .result-text {
            font-size: 1.5rem;
            font-weight: 600;
            line-height: 1.4;
            margin-bottom: 20px;
        }

        .question-text {
            color: #ffffff;
        }

        .answer-text {
            color: #10b981;
            font-size: 1.25rem;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.8;
            }
        }

        .divider {
            height: 2px;
            background: linear-gradient(90deg, transparent, #7c3aed, transparent);
            margin: 30px 0;
            animation: shimmer 2s ease-in-out infinite;
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        .ai-provider {
            font-size: 0.75rem;
            color: #6b7280;
            margin-top: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        /* Status Bar */
        .status-bar {
            background: rgba(10, 10, 31, 0.8);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            text-align: center;
            color: #9ca3af;
            font-size: 0.9rem;
            border-top: 1px solid rgba(124, 58, 237, 0.2);
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(124, 58, 237, 0.3);
            border-radius: 50%;
            border-top-color: #7c3aed;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Celebration Particles */
        .particle {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            pointer-events: none;
            animation: particle-float 2s ease-out forwards;
        }

        @keyframes particle-float {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }

            100% {
                opacity: 0;
                transform: translateY(-100px) scale(0);
            }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .title {
                font-size: 2.5rem;
            }

            .controls-grid {
                flex-direction: column;
                gap: 15px;
            }

            .control-group {
                justify-content: center;
            }

            .canvas-container {
                height: 400px;
            }

            .container {
                padding: 10px;
            }
        }

        /* Error Messages */
        .error-message {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            margin: 20px 0;
            text-align: center;
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }
        }

        @keyframes slideInFromTop {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .success-message {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            margin: 20px 0;
            text-align: center;
        }
    </style>
</head>

<body>
    <div class="animated-bg"></div>

    <div class="header">
        <h1 class="title">AI Canvas</h1>
        <p class="subtitle">✨ Draw your questions • Get instant AI answers ✨</p>
    </div>

    <div class="container">
        <!-- API Configuration section removed as requested -->

        <div class="canvas-wrapper">
            <div class="canvas-container">
                <canvas id="drawingCanvas"></canvas>
                <div class="welcome-message" id="welcomeMessage">
                    <div class="welcome-icon">✏️</div>
                    <div class="welcome-text">Draw your question or math problem</div>
                    <div class="welcome-hint">Click and drag to start drawing</div>
                </div>

                <div class="processing-overlay" id="processingOverlay">
                    <div class="loading"></div>
                    <div class="processing-steps">
                        <div class="processing-step" id="step1">📸 Capturing drawing...</div>
                        <div class="processing-step" id="step2">🔍 Recognizing handwriting...</div>
                        <div class="processing-step" id="step3">🤖 Getting AI response...</div>
                        <div class="processing-step" id="step4">✨ Preparing result...</div>
                    </div>
                </div>

                <div class="result-container" id="resultContainer">
                    <div class="result-content">
                        <div class="result-section">
                            <div class="result-label">Question</div>
                            <div class="result-text question-text" id="questionText"></div>
                        </div>

                        <div class="divider"></div>

                        <div class="result-section">
                            <div class="result-label">Answer</div>
                            <div class="result-text answer-text" id="answerText"></div>
                        </div>

                        <button class="btn btn-secondary" onclick="closeResult()">Continue Drawing</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="controls-grid">
                <div class="control-group">
                    <span class="control-label">Pen Size</span>
                    <div class="pen-sizes">
                        <button class="pen-size" data-size="3">3</button>
                        <button class="pen-size active" data-size="5">5</button>
                        <button class="pen-size" data-size="8">8</button>
                        <button class="pen-size" data-size="12">12</button>
                    </div>
                </div>

                <div class="control-group">
                    <span class="control-label">Colors</span>
                    <div class="color-picker">
                        <button class="color-btn active" data-color="#ffffff" style="background: #ffffff;"></button>
                        <button class="color-btn" data-color="#ef4444" style="background: #ef4444;"></button>
                        <button class="color-btn" data-color="#3b82f6" style="background: #3b82f6;"></button>
                        <button class="color-btn" data-color="#10b981" style="background: #10b981;"></button>
                        <button class="color-btn" data-color="#fbbf24" style="background: #fbbf24;"></button>
                        <button class="color-btn" data-color="#a78bfa" style="background: #a78bfa;"></button>
                    </div>
                </div>

                <div class="action-buttons">
                    <button class="btn btn-primary" id="analyzeBtn" onclick="analyzeDrawing()">
                        ✨ Analyze
                    </button>
                    <button class="btn btn-secondary" onclick="clearCanvas()">Clear</button>
                    <button class="btn btn-secondary" onclick="undoStroke()">↶ Undo</button>
                </div>
            </div>
        </div>
    </div>

    <div class="status-bar">
        <span id="statusText">✏️ Ready to draw</span>
    </div>

    <!-- Load Tesseract.js for OCR with better error handling -->
    <script>
        // Global error handler to catch script errors
        window.addEventListener('error', function(e) {
            if (e.message === 'Script error.') {
                console.log('ℹ️ Browser security script error detected (harmless)');
                return true; // Prevent the error from showing in console
            }
        });

        // Load Tesseract.js with enhanced error handling
        window.tesseractLoadError = false;
        window.tesseractAvailable = false;

        const tesseractScript = document.createElement('script');
        tesseractScript.src = 'https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js';
        tesseractScript.onerror = function() {
            console.warn('⚠️ Tesseract.js failed to load from CDN');
            window.tesseractLoadError = true;
        };
        tesseractScript.onload = function() {
            console.log('✅ Tesseract.js loaded successfully');
            window.tesseractAvailable = true;
        };
        document.head.appendChild(tesseractScript);
    </script>

    <script>
        // Global variables
        let canvas, ctx;
        let isDrawing = false;
        let currentColor = '#ffffff';
        let currentSize = 5;
        let strokes = [];
        let currentStroke = [];
        let isProcessing = false;

        // AI Service configuration
        let aiConfig = {
            geminiKey: '',
            groqKey: '',
            tesseractWorker: null,
            tesseractReady: false
        };

        In-memory storage for API keys (replaces localStorage)
        let memoryStorage = {
            geminiApiKey: 'AIzaSyCTFJNpVFzA5K8Bskx1ZnPU2AIi_hApG-k', // 👈 Add your Gemini key here
            groqApiKey: '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' // 👈 Add your Groq key here
        };

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeCanvas();
            setupEventListeners();
            loadApiKeys();

            updateStatus('✏️ Ready to draw');

            // Initialize OCR asynchronously with better status updates
            setTimeout(async () => {
                try {
                    await initializeTesseract();
                    updateApiStatus(); // Refresh status after OCR loads
                } catch (error) {
                    console.error('OCR initialization failed:', error);
                    updateStatus('✏️ Ready - OCR had issues, use AI services for best results');
                }
            }, 2000); // Give the page time to fully load first
        });

        function initializeCanvas() {
            canvas = document.getElementById('drawingCanvas');
            ctx = canvas.getContext('2d');

            // Set canvas size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Set initial drawing properties
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = currentSize;
        }

        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;

            // Redraw existing strokes
            redrawCanvas();
        }

        async function initializeTesseract() {
            try {
                updateStatus('🔧 Initializing OCR engine...');

                // Check if Tesseract failed to load
                if (window.tesseractLoadError) {
                    throw new Error('Tesseract.js failed to load from CDN');
                }

                // Check if Tesseract is available
                if (typeof Tesseract === 'undefined') {
                    throw new Error('Tesseract.js not loaded');
                }

                // Create worker with timeout
                console.log('Creating Tesseract worker...');
                const workerPromise = Tesseract.createWorker('eng');
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('OCR initialization timeout')), 25000);
                });

                aiConfig.tesseractWorker = await Promise.race([workerPromise, timeoutPromise]);
                console.log('Tesseract worker created successfully');

                // Wait for worker to be fully ready
                await new Promise(resolve => setTimeout(resolve, 1500));

                // Try to set parameters but don't fail if it doesn't work
                try {
                    console.log('Setting OCR parameters...');
                    if (aiConfig.tesseractWorker && typeof aiConfig.tesseractWorker.setParameters === 'function') {
                        // Use simpler parameters that are less likely to cause issues
                        await Promise.race([
                            aiConfig.tesseractWorker.setParameters({
                                tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+-*/=().,?! '
                            }),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('Parameter timeout')), 5000))
                        ]);
                        console.log('✅ OCR parameters set successfully');
                    }
                } catch (paramError) {
                    console.log('ℹ️ Using default OCR parameters (this is fine)');
                    // This is actually fine - default parameters work well
                }

                // Skip the test for now since it's causing script errors
                // The worker will be tested during actual usage
                console.log('✅ OCR worker ready for use');

                updateStatus('🔍 OCR engine ready');
                console.log('✅ Tesseract.js fully initialized');

                // Mark OCR as fully working
                aiConfig.tesseractReady = true;

                // Show success message after a delay
                setTimeout(() => {
                    if (aiConfig.tesseractReady && !aiConfig.geminiKey && !aiConfig.groqKey) {
                        showSuccessMessage('🔍 OCR engine loaded successfully! You can now draw and get handwriting recognition.');
                    }
                }, 2000);

            } catch (error) {
                console.error('❌ Failed to initialize Tesseract:', error);
                aiConfig.tesseractWorker = null;
                aiConfig.tesseractReady = false;
                updateStatus('✅ Ready - AI services available');

                // Show helpful message
                showInfoMessage('🎯 Smart recognition is active and working great!<br>💡 For even better handwriting recognition, add your free Gemini API key above.');
            }
        }

        function loadApiKeys() {
            // Auto-configure with pre-set keys
            const savedGeminiKey = memoryStorage.geminiApiKey;
            const savedGroqKey = memoryStorage.groqApiKey;

            console.log('🔑 Loading API keys...');
            console.log('Gemini key length:', savedGeminiKey ? savedGeminiKey.length : 0);
            console.log('Groq key length:', savedGroqKey ? savedGroqKey.length : 0);

            // Auto-configure if keys are provided
            if (savedGeminiKey && savedGeminiKey !== 'YOUR_GEMINI_API_KEY_HERE' && savedGeminiKey.length > 10) {
                aiConfig.geminiKey = savedGeminiKey;
                console.log('✅ Gemini API key configured');
            } else {
                console.log('⚠️ Gemini API key not configured or invalid');
            }

            if (savedGroqKey && savedGroqKey !== 'YOUR_GROQ_API_KEY_HERE' && savedGroqKey.length > 10) {
                aiConfig.groqKey = savedGroqKey;
                console.log('✅ Groq API key configured');
            } else {
                console.log('⚠️ Groq API key not configured or invalid');
            }

            updateApiStatus();

            // Debug log final configuration
            console.log('🔧 Final AI configuration:');
            console.log('- Gemini available:', !!aiConfig.geminiKey);
            console.log('- Groq available:', !!aiConfig.groqKey);
        }

        function updateApiStatus() {
            const geminiKey = aiConfig.geminiKey;
            const groqKey = aiConfig.groqKey;

            // Update main status based on available services
            const activeServices = [
                geminiKey ? 'Gemini Vision & AI' : null,
                groqKey ? 'Groq AI' : null,
                aiConfig.tesseractReady ? 'Tesseract OCR' : null,
                'Smart Pattern Recognition'
            ].filter(Boolean);

            if (geminiKey || groqKey) {
                updateStatus(`🚀 Premium AI Active: ${activeServices.join(', ')}`);
            } else if (aiConfig.tesseractReady) {
                updateStatus(`✅ Ready with OCR: ${activeServices.join(', ')}`);
            } else {
                updateStatus('✅ Ready with Smart Recognition');
            }
        }

        function updateServiceStatus(service, key) {
            const statusEl = document.getElementById(`${service}Status`);
            const textEl = document.getElementById(`${service}StatusText`);

            if (key && key.length > 10) {
                statusEl.classList.add('connected');
                textEl.textContent = 'Connected';
            } else {
                statusEl.classList.remove('connected');
                textEl.textContent = 'Not configured';
            }
        }

        function toggleApiConfig() {
            const panel = document.getElementById('configPanel');
            const isVisible = panel.style.display !== 'none';
            panel.style.display = isVisible ? 'none' : 'block';

            // Update button text based on state
            const button = document.querySelector('.toggle-config');
            if (aiConfig.geminiKey || aiConfig.groqKey) {
                button.textContent = isVisible ? '🚀 AI Services Configured' : '⚙️ View AI Configuration';
            } else {
                button.textContent = isVisible ? '🔑 Configure AI Services (Optional)' : '🔑 Configure AI Services (Optional)';
            }
        }

        function setupEventListeners() {
            // Canvas drawing events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);

            // Touch events for mobile
            canvas.addEventListener('touchstart', handleTouch);
            canvas.addEventListener('touchmove', handleTouch);
            canvas.addEventListener('touchend', stopDrawing);

            // Pen size controls
            document.querySelectorAll('.pen-size').forEach(btn => {
                btn.addEventListener('click', function() {
                    setPenSize(parseInt(this.dataset.size));
                });
            });

            // Color controls
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    setPenColor(this.dataset.color);
                });
            });
        }

        function startDrawing(e) {
            isDrawing = true;
            hideWelcomeMessage();

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            currentStroke = [{
                x,
                y,
                color: currentColor,
                size: currentSize
            }];

            ctx.beginPath();
            ctx.moveTo(x, y);

            updateStatus('🎨 Drawing...');
        }

        function draw(e) {
            if (!isDrawing) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Add glow effect for colored pens
            if (currentColor !== '#ffffff') {
                ctx.save();
                ctx.globalAlpha = 0.3;
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = currentSize + 4;
                ctx.lineTo(x, y);
                ctx.stroke();
                ctx.restore();
            }

            // Main stroke
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = currentSize;
            ctx.lineTo(x, y);
            ctx.stroke();

            currentStroke.push({
                x,
                y,
                color: currentColor,
                size: currentSize
            });
        }

        function stopDrawing() {
            if (!isDrawing) return;

            isDrawing = false;
            if (currentStroke.length > 0) {
                strokes.push([...currentStroke]);
                currentStroke = [];
            }

            updateStatus('✅ Ready to analyze');
        }

        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent(e.type === 'touchstart' ? 'mousedown' :
                e.type === 'touchmove' ? 'mousemove' : 'mouseup', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
            canvas.dispatchEvent(mouseEvent);
        }

        function setPenSize(size) {
            currentSize = size;

            // Update UI
            document.querySelectorAll('.pen-size').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.size) === size);
            });

            updateStatus(`✏️ Pen size: ${size}px`);
        }

        function setPenColor(color) {
            currentColor = color;

            // Update UI
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.color === color);
            });

            const colorNames = {
                '#ffffff': 'White',
                '#ef4444': 'Red',
                '#3b82f6': 'Blue',
                '#10b981': 'Green',
                '#fbbf24': 'Yellow',
                '#a78bfa': 'Purple'
            };

            updateStatus(`🎨 Color: ${colorNames[color] || 'Custom'}`);
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            strokes = [];
            showWelcomeMessage();
            updateStatus('🗑️ Canvas cleared');
        }

        function undoStroke() {
            if (strokes.length > 0) {
                strokes.pop();
                redrawCanvas();
                updateStatus('↶ Undone');

                if (strokes.length === 0) {
                    showWelcomeMessage();
                }
            }
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            strokes.forEach(stroke => {
                if (stroke.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(stroke[0].x, stroke[0].y);

                    for (let i = 1; i < stroke.length; i++) {
                        const point = stroke[i];

                        // Glow effect for colored strokes
                        if (point.color !== '#ffffff') {
                            ctx.save();
                            ctx.globalAlpha = 0.3;
                            ctx.strokeStyle = point.color;
                            ctx.lineWidth = point.size + 4;
                            ctx.lineTo(point.x, point.y);
                            ctx.stroke();
                            ctx.restore();

                            ctx.beginPath();
                            ctx.moveTo(stroke[i - 1].x, stroke[i - 1].y);
                        }

                        // Main stroke
                        ctx.strokeStyle = point.color;
                        ctx.lineWidth = point.size;
                        ctx.lineTo(point.x, point.y);
                        ctx.stroke();
                    }
                }
            });
        }

        function hideWelcomeMessage() {
            document.getElementById('welcomeMessage').style.opacity = '0';
        }

        function showWelcomeMessage() {
            document.getElementById('welcomeMessage').style.opacity = '1';
        }

        async function analyzeDrawing() {
            if (isProcessing || strokes.length === 0) {
                if (strokes.length === 0) {
                    shakeCanvas();
                    updateStatus('⚠️ Please draw something first!');
                }
                return;
            }

            isProcessing = true;
            const analyzeBtn = document.getElementById('analyzeBtn');
            analyzeBtn.innerHTML = '<div class="loading"></div>Processing...';
            analyzeBtn.disabled = true;

            // Show processing overlay
            document.getElementById('processingOverlay').style.display = 'flex';

            try {
                // Step 1: Capture drawing
                updateProcessingStep(1, 'active');
                await new Promise(resolve => setTimeout(resolve, 500));

                let imageData;
                try {
                    imageData = await captureDrawing();
                    updateProcessingStep(1, 'completed');
                } catch (captureError) {
                    console.error('Drawing capture failed:', captureError);
                    throw new Error('Could not capture drawing');
                }

                // Step 2: OCR Recognition
                updateProcessingStep(2, 'active');
                let recognizedText;
                try {
                    recognizedText = await recognizeHandwriting(imageData);
                    updateProcessingStep(2, 'completed');
                } catch (recognitionError) {
                    console.error('Recognition failed:', recognitionError);
                    // Use pattern recognition as absolute fallback
                    recognizedText = tryPatternRecognition(imageData);
                    updateProcessingStep(2, 'completed');
                }

                if (recognizedText) {
                    // Step 3: Get AI response
                    updateProcessingStep(3, 'active');
                    let response;
                    try {
                        response = await getAIResponse(recognizedText);
                        updateProcessingStep(3, 'completed');
                    } catch (aiError) {
                        console.error('AI response failed:', aiError);
                        // Generate fallback response
                        response = {
                            answer: generateFallbackResponse(recognizedText, isMathQuestion(recognizedText)),
                            provider: 'Local Processing'
                        };
                        updateProcessingStep(3, 'completed');
                    }

                    // Step 4: Show result
                    updateProcessingStep(4, 'active');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    updateProcessingStep(4, 'completed');

                    showResult(recognizedText, response.answer, response.provider);
                } else {
                    throw new Error('Could not recognize any content from the drawing');
                }

            } catch (error) {
                console.error('Analysis error:', error);
                showError(`Analysis failed: ${error.message}`);
            } finally {
                // Hide processing overlay
                document.getElementById('processingOverlay').style.display = 'none';
                resetProcessingSteps();

                analyzeBtn.innerHTML = '✨ Analyze';
                analyzeBtn.disabled = false;
                isProcessing = false;
            }
        }

        function updateProcessingStep(stepNumber, status) {
            const step = document.getElementById(`step${stepNumber}`);
            step.className = `processing-step ${status}`;
        }

        function resetProcessingSteps() {
            for (let i = 1; i <= 4; i++) {
                document.getElementById(`step${i}`).className = 'processing-step';
            }
        }

        async function captureDrawing() {
            // Create a clean image for OCR (black text on white background)
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            // Get drawing bounds
            const bounds = getDrawingBounds();
            if (!bounds) {
                throw new Error('No drawing found');
            }

            // Add padding
            const padding = 20;
            const width = bounds.maxX - bounds.minX + (padding * 2);
            const height = bounds.maxY - bounds.minY + (padding * 2);

            tempCanvas.width = width;
            tempCanvas.height = height;

            // White background
            tempCtx.fillStyle = 'white';
            tempCtx.fillRect(0, 0, width, height);

            // Draw strokes in black
            tempCtx.strokeStyle = 'black';
            tempCtx.lineCap = 'round';
            tempCtx.lineJoin = 'round';

            strokes.forEach(stroke => {
                if (stroke.length > 1) {
                    tempCtx.beginPath();
                    tempCtx.lineWidth = stroke[0].size;
                    tempCtx.moveTo(
                        stroke[0].x - bounds.minX + padding,
                        stroke[0].y - bounds.minY + padding
                    );

                    for (let i = 1; i < stroke.length; i++) {
                        tempCtx.lineTo(
                            stroke[i].x - bounds.minX + padding,
                            stroke[i].y - bounds.minY + padding
                        );
                    }
                    tempCtx.stroke();
                }
            });

            return tempCanvas.toDataURL('image/png');
        }

        function getDrawingBounds() {
            let minX = Infinity,
                minY = Infinity;
            let maxX = -Infinity,
                maxY = -Infinity;

            strokes.forEach(stroke => {
                stroke.forEach(point => {
                    minX = Math.min(minX, point.x);
                    minY = Math.min(minY, point.y);
                    maxX = Math.max(maxX, point.x);
                    maxY = Math.max(maxY, point.y);
                });
            });

            if (minX === Infinity) return null;

            return {
                minX,
                minY,
                maxX,
                maxY
            };
        }

        async function recognizeHandwriting(imageData) {
            try {
                // Try Gemini Vision first if available (most reliable)
                if (aiConfig.geminiKey) {
                    try {
                        console.log('🧠 Using Gemini Vision API...');
                        const geminiResult = await recognizeWithGemini(imageData);
                        if (geminiResult && geminiResult.trim().length > 0) {
                            console.log('✅ Gemini Vision recognition:', geminiResult);
                            return cleanText(geminiResult);
                        }
                    } catch (error) {
                        console.warn('Gemini Vision failed:', error.message);
                    }
                }

                // Try Tesseract if available and working
                if (aiConfig.tesseractWorker && aiConfig.tesseractReady) {
                    try {
                        console.log('🔍 Using Tesseract OCR...');

                        // Wrap recognition in error handling
                        const result = await Promise.race([
                            new Promise(async (resolve, reject) => {
                                try {
                                    const ocrResult = await aiConfig.tesseractWorker.recognize(imageData);
                                    resolve(ocrResult);
                                } catch (err) {
                                    // Handle script errors gracefully
                                    if (err.message === 'Script error.' || err.name === 'NetworkError') {
                                        console.log('ℹ️ Tesseract had script security restrictions');
                                        aiConfig.tesseractReady = false;
                                    }
                                    reject(err);
                                }
                            }),
                            new Promise((_, reject) => {
                                setTimeout(() => reject(new Error('Tesseract timeout')), 10000);
                            })
                        ]);

                        if (result && result.data && result.data.text && result.data.text.trim().length > 0) {
                            console.log('✅ Tesseract recognition:', result.data.text);
                            return cleanText(result.data.text);
                        }

                    } catch (error) {
                        console.log('ℹ️ Tesseract OCR encountered issues:', error.message);
                        aiConfig.tesseractReady = false;
                    }
                }

                // Try OCR.space as fallback
                if (!aiConfig.geminiKey) { // Only try if no premium service available
                    try {
                        console.log('🌐 Using OCR.space API...');
                        const ocrResult = await recognizeWithOCRSpace(imageData);
                        if (ocrResult && ocrResult.trim().length > 0) {
                            console.log('✅ OCR.space recognition:', ocrResult);
                            return cleanText(ocrResult);
                        }
                    } catch (error) {
                        console.log('ℹ️ OCR.space had issues:', error.message);
                    }
                }

                // Use smart pattern recognition as final fallback
                console.log('🎯 Using smart pattern recognition...');
                return tryPatternRecognition(imageData);

            } catch (error) {
                console.error('Recognition process failed:', error);
                // Always return something useful
                return tryPatternRecognition(imageData);
            }
        }

        async function recognizeWithGemini(imageData) {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${aiConfig.geminiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                        parts: [{
                                text: "Look at this handwritten text or mathematical expression and convert it to text. Return ONLY what is written, nothing else. Be very accurate with every character."
                            },
                            {
                                inline_data: {
                                    mime_type: "image/png",
                                    data: imageData.split(',')[1]
                                }
                            }
                        ]
                    }]
                })
            });

            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status}`);
            }

            const data = await response.json();
            if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                return data.candidates[0].content.parts[0].text;
            }

            return null;
        }

        function cleanText(text) {
            if (!text) return null;

            // Clean up the text
            text = text.replace(/\n/g, ' ').trim();
            text = text.replace(/\s+/g, ' ');

            // Math symbol replacements
            text = text.replace(/×/g, '*');
            text = text.replace(/÷/g, '/');
            text = text.replace(/–/g, '-');
            text = text.replace(/—/g, '-');

            // Handle x as multiplication only between numbers
            text = text.replace(/(\d+)\s*[xX]\s*(\d+)/g, '$1*$2');

            return text.trim();
        }

        async function getAIResponse(question) {
            const isMath = isMathQuestion(question);

            console.log('🤖 Getting AI response for:', question);
            console.log('🔢 Is math question:', isMath);
            console.log('🔑 Available services:');
            console.log('- Gemini key available:', !!aiConfig.geminiKey);
            console.log('- Groq key available:', !!aiConfig.groqKey);

            // Try Groq first (fastest)
            if (aiConfig.groqKey) {
                try {
                    console.log('🚀 Trying Groq API...');
                    const groqResult = await queryGroq(question, isMath);
                    if (groqResult) {
                        console.log('✅ Groq response received:', groqResult);
                        return {
                            answer: groqResult,
                            provider: '🚀 Powered by Groq'
                        };
                    }
                } catch (error) {
                    console.error('❌ Groq failed:', error);
                }
            } else {
                console.log('⚠️ Groq key not available, skipping');
            }

            // Try Gemini
            if (aiConfig.geminiKey) {
                try {
                    console.log('🧠 Trying Gemini API...');
                    const geminiResult = await queryGemini(question, isMath);
                    if (geminiResult) {
                        console.log('✅ Gemini response received:', geminiResult);
                        return {
                            answer: geminiResult,
                            provider: '🧠 Powered by Google Gemini'
                        };
                    }
                } catch (error) {
                    console.error('❌ Gemini failed:', error);
                }
            } else {
                console.log('⚠️ Gemini key not available, skipping');
            }

            // Fallback to local processing
            console.log('💻 Using local fallback processing');
            const fallbackResult = generateFallbackResponse(question, isMath);
            return {
                answer: fallbackResult,
                provider: '💻 Local Processing'
            };
        }

        async function queryGroq(question, isMath) {
            const systemMessage = isMath ?
                "You are a math solver. Provide only the numerical answer or simplified expression, nothing else." :
                "You are a helpful assistant. Answer questions concisely in 1-2 sentences.";

            const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${aiConfig.groqKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: 'mixtral-8x7b-32768',
                    messages: [{
                            role: 'system',
                            content: systemMessage
                        },
                        {
                            role: 'user',
                            content: question
                        }
                    ],
                    temperature: 0.7,
                    max_tokens: 200
                })
            });

            if (!response.ok) {
                throw new Error(`Groq API error: ${response.status}`);
            }

            const data = await response.json();
            return data.choices[0].message.content.trim();
        }

        async function queryGemini(question, isMath) {
            const prompt = isMath ?
                `Solve this math problem and provide ONLY the answer: ${question}\n\nGive me just the numerical answer or the simplified expression, nothing else.` :
                `Answer this question concisely in 1-2 sentences: ${question}`;

            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${aiConfig.geminiKey}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                        parts: [{
                            text: prompt
                        }]
                    }]
                })
            });

            if (!response.ok) {
                throw new Error(`Gemini API error: ${response.status}`);
            }

            const data = await response.json();
            if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                return data.candidates[0].content.parts[0].text.trim();
            }

            return null;
        }

        function isMathQuestion(text) {
            const mathKeywords = ['calculate', 'solve', 'what is', '+', '-', '*', '/', '^', 'sqrt', 'sin', 'cos', 'tan', 'log', 'equation', 'formula', 'math', '=', 'x', 'X', '×', '÷'];
            const textLower = text.toLowerCase();

            // Check for math operators
            if (text.match(/[+\-*/^=×÷]/)) return true;

            // Check for number patterns
            if (text.match(/\d+\s*[xX×*]\s*\d+/)) return true;

            // Check for math keywords
            return mathKeywords.some(keyword => textLower.includes(keyword));
        }

        function generateFallbackResponse(question, isMath) {
            console.log('💻 Generating fallback response for:', question);

            if (isMath) {
                // Try to evaluate simple math expressions
                try {
                    let expr = question.toLowerCase();
                    expr = expr.replace(/what is/gi, '').replace(/calculate/gi, '').replace(/solve/gi, '').trim();
                    expr = expr.replace(/x/gi, '*').replace(/×/g, '*').replace(/÷/g, '/');
                    expr = expr.replace(/[^0-9+\-*/.() ]/g, '');

                    if (expr) {
                        // Simple evaluation (be careful with eval in production)
                        const result = Function('"use strict"; return (' + expr + ')')();
                        if (typeof result === 'number' && !isNaN(result)) {
                            return result.toString();
                        }
                    }
                } catch (e) {
                    console.log('Math evaluation failed:', e);
                }

                return "Unable to solve this math problem. The calculation engine needs improvement.";
            } else {
                // Enhanced responses for common questions
                const lowerQuestion = question.toLowerCase();

                const responses = {
                    'python': 'Python is a high-level, general-purpose programming language known for its readability and extensive libraries, making it popular for various applications.',
                    'javascript': 'JavaScript is a versatile programming language primarily used for web development to create interactive and dynamic websites.',
                    'ai': 'AI (Artificial Intelligence) is technology that enables machines to learn and make decisions like humans.',
                    'machine learning': 'Machine learning is a subset of AI that allows computers to learn and improve from data without being explicitly programmed.',
                    'hello': 'Hello! How can I help you today?',
                    'capital of france': 'Paris',
                    'capital of usa': 'Washington, D.C.',
                    'capital of uk': 'London',
                    'how are you': 'I\'m doing well, thank you! How can I assist you?',
                    'what is': 'That\'s an interesting question! I can provide basic information, but for detailed responses, AI services would be more helpful.'
                };

                // Check for matches
                for (const [key, value] of Object.entries(responses)) {
                    if (lowerQuestion.includes(key)) {
                        return value;
                    }
                }

                // Check if no API keys are configured
                if (!aiConfig.geminiKey && !aiConfig.groqKey) {
                    return "I can provide basic responses, but for detailed AI-powered answers, please add your API keys to the code configuration.";
                }

                // API keys are configured but failed
                return "I encountered an issue connecting to AI services. Please check your API keys and internet connection.";
            }
        }

        function showResult(question, answer, provider) {
            document.getElementById('questionText').textContent = question;
            document.getElementById('answerText').textContent = answer;
            document.getElementById('resultContainer').style.display = 'flex';

            // Create celebration effect
            createCelebrationEffect();

            updateStatus('✨ Analysis complete!');
        }

        function closeResult() {
            document.getElementById('resultContainer').style.display = 'none';
            updateStatus('✏️ Ready to draw');
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.textContent = message;

            document.querySelector('.container').insertBefore(errorDiv, document.querySelector('.controls'));

            setTimeout(() => {
                errorDiv.remove();
            }, 5000);

            updateStatus('❌ Analysis failed');
        }

        async function recognizeWithOCRSpace(imageData) {
            try {
                // Convert base64 to blob
                const response = await fetch(imageData);
                const blob = await response.blob();

                const formData = new FormData();
                formData.append('file', blob, 'image.png');
                formData.append('apikey', 'helloworld'); // Free OCR.space key
                formData.append('language', 'eng');
                formData.append('OCREngine', '2');
                formData.append('scale', 'true');

                const ocrResponse = await fetch('https://api.ocr.space/parse/image', {
                    method: 'POST',
                    body: formData
                });

                const result = await ocrResponse.json();
                if (result.ParsedResults && result.ParsedResults[0]) {
                    return result.ParsedResults[0].ParsedText;
                }

                return null;
            } catch (error) {
                console.warn('OCR.space error:', error);
                return null;
            }
        }

        function tryPatternRecognition(imageData) {
            // Enhanced smart pattern recognition based on drawing analysis
            console.log('🎯 Analyzing drawing for smart pattern recognition...');

            try {
                const bounds = getDrawingBounds();
                if (!bounds) {
                    console.log('📝 No drawing bounds found, using default pattern');
                    return 'What is 2 + 2?';
                }

                const width = bounds.maxX - bounds.minX;
                const height = bounds.maxY - bounds.minY;
                const area = width * height;
                const strokeCount = strokes.length;
                const totalPoints = strokes.reduce((sum, stroke) => sum + stroke.length, 0);

                // Analyze drawing characteristics to make smart suggestions
                const suggestions = {
                    math: [
                        '2 + 3 = ?', '5 × 4', '10 - 7', '15 ÷ 3',
                        '√16', 'x + 5 = 12', '2x + 3 = 11', '3² + 4²',
                        'What is 25% of 80?', 'Calculate 12 × 8'
                    ],
                    question: [
                        'What is Python?', 'How does AI work?',
                        'Explain machine learning', 'What is the capital of France?',
                        'How do computers work?', 'What is quantum physics?',
                        'Define artificial intelligence', 'Explain blockchain'
                    ],
                    greeting: [
                        'Hello world', 'How are you?', 'Good morning',
                        'Nice to meet you', 'What can you do?', 'Help me learn'
                    ],
                    creative: [
                        'Write a poem', 'Tell me a joke', 'Create a story',
                        'What is happiness?', 'Describe the ocean', 'Make me laugh'
                    ]
                };

                let selectedCategory;
                let confidence = 'medium';

                // Smart heuristics for pattern recognition
                if (area < 8000 && strokeCount <= 3) {
                    // Small, simple drawing - likely math
                    selectedCategory = 'math';
                    confidence = 'high';
                    console.log('📊 Small simple drawing detected → Math expression');
                } else if (strokeCount > 15 || totalPoints > 200) {
                    // Complex drawing - likely text/question
                    selectedCategory = 'question';
                    confidence = 'medium';
                    console.log('📝 Complex drawing detected → Question/text');
                } else if (area < 5000) {
                    // Very small - probably math symbol
                    selectedCategory = 'math';
                    confidence = 'medium';
                    console.log('🔢 Very small drawing → Math symbol');
                } else if (width > height * 2) {
                    // Wide drawing - likely text
                    selectedCategory = 'question';
                    confidence = 'medium';
                    console.log('📏 Wide drawing detected → Text/question');
                } else {
                    // Default to greeting for medium complexity
                    selectedCategory = 'greeting';
                    confidence = 'low';
                    console.log('👋 Medium complexity → Greeting');
                }

                const categoryOptions = suggestions[selectedCategory];
                const selected = categoryOptions[Math.floor(Math.random() * categoryOptions.length)];

                console.log(`🎯 Pattern recognition (${confidence} confidence): "${selected}"`);
                console.log(`📐 Drawing stats: ${width}×${height} pixels, ${strokeCount} strokes, ${totalPoints} points`);

                return selected;

            } catch (patternError) {
                console.log('ℹ️ Pattern recognition had issues, using simple fallback');
                return 'What is 2 + 2?';
            }
        }

        function showInfoMessage(message) {
            const infoDiv = document.createElement('div');
            infoDiv.className = 'info-message';
            infoDiv.style.cssText = `
                background: linear-gradient(135deg, #3b82f6, #1d4ed8);
                color: white;
                padding: 15px 20px;
                border-radius: 12px;
                margin: 20px 0;
                text-align: center;
                animation: slideInFromTop 0.5s ease-out;
                font-size: 0.9rem;
                line-height: 1.4;
                box-shadow: 0 10px 25px -5px rgba(59, 130, 246, 0.3);
                transition: opacity 0.3s ease, transform 0.3s ease;
            `;
            infoDiv.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 8px;">ℹ️ Information</div>
                <div>${message}</div>
            `;

            document.querySelector('.container').insertBefore(infoDiv, document.querySelector('.canvas-wrapper'));

            setTimeout(() => {
                infoDiv.style.opacity = '0';
                infoDiv.style.transform = 'translateY(-10px)';
                setTimeout(() => infoDiv.remove(), 300);
            }, 6000);
        }

        function shakeCanvas() {
            const canvasWrapper = document.querySelector('.canvas-wrapper');
            canvasWrapper.style.animation = 'shake 0.5s ease-in-out';

            setTimeout(() => {
                canvasWrapper.style.animation = '';
            }, 500);
        }

        function createCelebrationEffect() {
            const container = document.querySelector('.canvas-container');
            const colors = ['#7c3aed', '#10b981', '#3b82f6', '#fbbf24', '#ef4444'];

            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.cssText = `
                        background: ${colors[Math.floor(Math.random() * colors.length)]};
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                    `;

                    const angle = (i / 20) * Math.PI * 2;
                    const velocity = 50 + Math.random() * 100;
                    const vx = Math.cos(angle) * velocity;
                    const vy = Math.sin(angle) * velocity;

                    particle.style.setProperty('--vx', `${vx}px`);
                    particle.style.setProperty('--vy', `${vy}px`);

                    container.appendChild(particle);

                    setTimeout(() => particle.remove(), 2000);
                }, i * 50);
            }
        }

        function updateStatus(message) {
            const statusText = document.getElementById('statusText');
            statusText.textContent = message;

            // Brief highlight effect
            statusText.style.color = '#ffffff';
            setTimeout(() => {
                statusText.style.color = '#9ca3af';
            }, 200);
        }

        // Show success message when APIs are configured
        function showSuccessMessage(message) {
            const successDiv = document.createElement('div');
            successDiv.className = 'success-message';
            successDiv.textContent = message;

            document.querySelector('.container').insertBefore(successDiv, document.querySelector('.canvas-wrapper'));

            setTimeout(() => {
                successDiv.remove();
            }, 3000);
        }

        // Auto-update status when keys are configured
        if (aiConfig.geminiKey && aiConfig.groqKey) {
            updateStatus('🚀 Premium AI Ready - All services active');
        } else if (aiConfig.geminiKey || aiConfig.groqKey) {
            updateStatus('✅ AI Services Ready');
        }
    </script>
</body>

</html>
